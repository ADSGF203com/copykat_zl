#'
#' @examples
#' test.ck <- copykat(rawmat=rawdata, sam.name="test", n.cores=10)
#'
#' test.pred <- test.ck$prediction
#' @export
copykat <- function(rawmat=rawdata, id.type="S", ngene.chr=5,LOW.DR=0.05, UP.DR=0.2, win.size=25, norm.cell.names="", KS.cut=0.15, sam.name="", distance="euclidean", n.cores=1){
sample.name <- paste(sam.name,"_copykat_", sep="")
start_time <- Sys.time()
print("test copykat v0")
print("step1: read and filter data ...")
print(paste(nrow(rawmat), " genes, ", ncol(rawmat), " cells in raw data", sep=""))
genes.raw <- apply(rawmat, 2, function(x)(sum(x>0)));
if(sum(genes.raw> 100)==0) stop("none cells have more than 200 genes")
if(sum(genes.raw<100)>1){
rawmat <- rawmat[, -which(genes.raw< 200)];
print(paste("filtered out ", sum(genes.raw<=200), " cells with less than 200 genes; remaining ", ncol(rawmat), " cells", sep=""))
}
##
der<- apply(rawmat,1,function(x)(sum(x>0)))/ncol(rawmat);
if(sum(der>LOW.DR)>=1){
rawmat <- rawmat[which(der > LOW.DR), ]; print(paste(nrow(rawmat)," genes past LOW.DR filtering", sep=""))
}
WNS1 <- "data quality is ok"
if(nrow(rawmat) < 7000){
WNS1 <- "low data quality"
UP.DR<- LOW.DR
print("WARNING: low data quality; assigned LOW.DR to UP.DR...")
}
print("step 2: annotations gene coordinates ...")
anno.mat <- annotateGenes.hg20(mat = rawmat, ID.type = id.type) #SYMBOL or ENSEMBLE
# print(paste(nrow(anno.mat)," genes annotated", sep=""))
### module 3 removing genes that are involved in cell cycling
HLAs <- anno.mat$hgnc_symbol[grep("^HLA-", anno.mat$hgnc_symbol)]
toRev <- which(anno.mat$hgnc_symbol %in% c(as.vector(cyclegenes[[1]]), HLAs))
if(length(toRev)>0){
anno.mat <- anno.mat[-toRev, ]
}
#  print(paste(nrow(anno.mat)," genes after rm cell cycle genes", sep=""))
### secondary filtering
ToRemov2 <- NULL
for(i in 8:ncol(anno.mat)){
cell <- cbind(anno.mat$chromosome_name, anno.mat[,i])
cell <- cell[cell[,2]!=0,]
if(length(as.numeric(cell))< 5){
rm <- colnames(anno.mat)[i]
ToRemov2 <- c(ToRemov2, rm)
} else if(length(rle(cell[,1])$length)<23|min(rle(cell[,1])$length)< ngene.chr){
rm <- colnames(anno.mat)[i]
ToRemov2 <- c(ToRemov2, rm)
}
i<- i+1
}
if(length(ToRemov2)==(ncol(anno.mat)-7)) stop("all cells are filtered")
if(length(ToRemov2)>0){
anno.mat <-anno.mat[, -which(colnames(anno.mat) %in% ToRemov2)]
}
# print(paste("filtered out ", length(ToRemov2), " cells with less than ",ngene.chr, " genes per chr", sep=""))
rawmat3 <- data.matrix(anno.mat[, 8:ncol(anno.mat)])
norm.mat<- log(sqrt(rawmat3)+sqrt(rawmat3+1))
norm.mat<- apply(norm.mat,2,function(x)(x <- x-mean(x)))
colnames(norm.mat) <-  colnames(rawmat3)
#print(paste("A total of ", ncol(norm.mat), " cells, ", nrow(norm.mat), " genes after preprocessing", sep=""))
##smooth data
print("step 3: smoothing data with dlm ...")
dlm.sm <- function(c){
model <- dlm::dlmModPoly(order=1, dV=0.16, dW=0.001)
x <- dlm::dlmSmooth(norm.mat[, c], model)$s
x<- x[2:length(x)]
x <- x-mean(x)
}
test.mc <-parallel::mclapply(1:ncol(norm.mat), dlm.sm, mc.cores = n.cores)
norm.mat.smooth <- matrix(unlist(test.mc), ncol = ncol(norm.mat), byrow = FALSE)
colnames(norm.mat.smooth) <- colnames(norm.mat)
print("step 4: measuring baselines ...")
if(length(norm.cell.names)>1){
#print(paste(length(norm.cell.names), "normal cells provided", sep=""))
NNN <- length(colnames(norm.mat.smooth)[which(colnames(norm.mat.smooth) %in% norm.cell.names)])
print(paste(NNN, " known normal cells found in dataset", sep=""))
if (NNN==0) stop("known normal cells provided; however none existing in testing dataset")
print("run with known normal...")
basel <- apply(norm.mat.smooth[, which(colnames(norm.mat.smooth) %in% norm.cell.names)],1,median); print("baseline is from known input")
d <- parallelDist::parDist(t(norm.mat.smooth),threads =n.cores, method="euclidean") ##use smooth and segmented data to detect intra-normal cells
km <- 6
fit <- hclust(d, method="ward.D2")
CL <- cutree(fit, km)
while(!all(table(ct)>min.cells)){
km <- km -1
CL <- cutree(fit, k=km)
if(km==2){
break
}
}
WNS <- "run with known normal"
preN <- norm.cell.names
}else {
basa <- baseline.norm.cl(norm.mat.smooth=norm.mat.smooth, min.cells=5, n.cores=n.cores)
basel <- basa$basel
WNS <- basa$WNS
preN <- basa$preN
CL <- basa$cl
if (WNS =="unclassified.prediction"){
basa <- baseline.GMM(CNA.mat=norm.mat.smooth, max.normal=15, mu.cut=0.05, Nfraq.cut=0.99, n.cores)
basel <-basa$basel
WNS <- basa$WNS
preN <- basa$preN
CL <- basa$cl
}
}
###use a smaller set of genes to perform segmentation
DR2 <- apply(rawmat3,1,function(x)(sum(x>0)))/ncol(rawmat3)
##relative expression using pred.normal cells
norm.mat.relat <- norm.mat.smooth-basel  ####
norm.mat.relat <- norm.mat.relat[which(DR2>=UP.DR),]
###filter cells
anno.mat2 <- anno.mat[which(DR2>=UP.DR), ]
ToRemov3 <- NULL
for(i in 8:ncol(anno.mat2)){
cell <- cbind(anno.mat2$chromosome_name, anno.mat2[,i])
cell <- cell[cell[,2]!=0,]
if(length(as.numeric(cell))< 5){
rm <- colnames(anno.mat2)[i]
ToRemov3 <- c(ToRemov3, rm)
} else if(length(rle(cell[,1])$length)<23|min(rle(cell[,1])$length)< ngene.chr){
rm <- colnames(anno.mat2)[i]
ToRemov3 <- c(ToRemov3, rm)
}
i<- i+1
}
if(length(ToRemov3)==ncol(norm.mat.relat)) stop ("all cells are filtered")
if(length(ToRemov3)>0){
norm.mat.relat <-norm.mat.relat[, -which(colnames(norm.mat.relat) %in% ToRemov3)]
# print(paste("filtered out ", length(ToRemov3), " cells with less than ",ngene.chr, " genes per chr", sep=""))
}
#print(paste("final segmentation: ", nrow(norm.mat.relat), " genes; ", ncol(norm.mat.relat), " cells", sep=""))
CL <- CL[which(names(CL) %in% colnames(norm.mat.relat))]
CL <- CL[order(match(names(CL), colnames(norm.mat.relat)))]
print("step 5: segmentation...")
results <- CNA.MCMC(clu=CL, fttmat=norm.mat.relat, bins=win.size, cut.cor = KS.cut, n.cores=n.cores)
if(length(results$breaks)<25){
print("too few breakpoints detected; decreased KS.cut to 50%")
results <- CNA.MCMC(clu=CL, fttmat=norm.mat.relat, bins=win.size, cut.cor = 0.5*KS.cut, n.cores=n.cores)
}
if(length(results$breaks)<25){
print("too few breakpoints detected; decreased KS.cut to 75%")
results <- CNA.MCMC(clu=CL, fttmat=norm.mat.relat, bins=win.size, cut.cor = 0.5*0.5*KS.cut, n.cores=n.cores)
}
if(length(results$breaks)<25) stop ("too few segments; try to decrease KS.cut; or improve data")
colnames(results$logCNA) <- colnames(norm.mat.relat)
results.com <- apply(results$logCNA,2, function(x)(x <- x-mean(x)))
RNA.copycat <- cbind(anno.mat2[, 1:7], results.com)
print("step 6: convert to genomic bins...") ###need multi-core
Aj <- convert.all.bins.hg20(DNA.mat = DNA.hg20, RNA.mat=RNA.copycat, n.cores = n.cores)
uber.mat.adj <- data.matrix(Aj$RNA.adj[, 4:ncol(Aj$RNA.adj)])
print("step 7: adjust baseline ...")
################removed baseline adjustment
hcc <- hclust(parallelDist::parDist(t(uber.mat.adj),threads =n.cores, method = "euclidean"), method = "ward.D2")
hc.umap <- cutree(hcc,2)
names(hc.umap) <- colnames(results.com)
cl.ID <- NULL
for(i in 1:max(hc.umap)){
cli <- names(hc.umap)[which(hc.umap==i)]
pid <- length(intersect(cli, preN))/length(cli)
cl.ID <- c(cl.ID, pid)
i<- i+1
}
com.pred <- names(hc.umap)
com.pred[which(hc.umap == which(cl.ID==max(cl.ID)))] <- "diploid"
com.pred[which(hc.umap == which(cl.ID==min(cl.ID)))] <- "nondiploid"
names(com.pred) <- names(hc.umap)
################removed baseline adjustment
results.com.rat <- uber.mat.adj-apply(uber.mat.adj[,which(com.pred=="diploid")], 1, mean)
results.com.rat <- apply(results.com.rat,2,function(x)(x <- x-mean(x)))
results.com.rat.norm <- results.com.rat[,which(com.pred=="diploid")]; dim(results.com.rat.norm)
cf.h <- apply(results.com.rat.norm, 1, sd)
base <- apply(results.com.rat.norm, 1, mean)
adjN <- function(j){
a <- results.com.rat[, j]
a[abs(a-base) <= 0.25*cf.h] <- mean(a)
a
}
mc.adjN <-  parallel::mclapply(1:ncol(results.com.rat),adjN, mc.cores = n.cores)
adj.results <- matrix(unlist(mc.adjN), ncol = ncol(results.com.rat), byrow = FALSE)
colnames(adj.results) <- colnames(results.com.rat)
rang <- 0.5*(max(adj.results)-min(adj.results))
mat.adj <- adj.results/rang
print("step 8: final prediction ...")
hcc <- hclust(parallelDist::parDist(t(mat.adj),threads =n.cores, method = "euclidean"), method = "ward.D2")
#hcc <- hclust(as.dist(1-cor(mat.adj, method = "spearman")), method = "ward.D2")
hc.umap <- cutree(hcc,2)
names(hc.umap) <- colnames(results.com)
saveRDS(hcc, file = paste(sample.name,"clustering_results.rda",sep=""))
cl.ID <- NULL
for(i in 1:max(hc.umap)){
cli <- names(hc.umap)[which(hc.umap==i)]
pid <- length(intersect(cli, preN))/length(cli)
cl.ID <- c(cl.ID, pid)
i<- i+1
}
com.preN <- names(hc.umap)
com.preN[which(hc.umap == which(cl.ID==max(cl.ID)))] <- "diploid"
com.preN[which(hc.umap == which(cl.ID==min(cl.ID)))] <- "aneuploid"
names(com.preN) <- names(hc.umap)
if(WNS=="unclassified.prediction"){
com.preN[which(com.preN == "diploid")] <- "c1:low.confidence"
com.preN[which(com.preN == "nondiploid")] <- "c2:low.confidence"
}
print("step 9: saving results...")
res <- cbind(names(com.preN), com.preN)
colnames(res) <- c("cell.names", "copykat.pred")
write.table(res, paste(sample.name, "prediction.txt",sep=""), sep="\t", row.names = FALSE, quote = F)
####save copycat CNA
write.table(cbind(Aj$RNA.adj[, 1:3], mat.adj), paste(sample.name, "CNA_results.txt", sep=""), sep="\t", row.names = FALSE, quote = F)
####%%%%%%%%%%%%%%%%%next heatmaps, subpopulations and tSNE overlay
print("step 10: ploting heatmap ...")
my_palette <- colorRampPalette(rev(RColorBrewer::brewer.pal(n = 3, name = "RdBu")))(n = 999)
chr <- as.numeric(Aj$DNA.adj$chrom) %% 2+1
rbPal1 <- colorRampPalette(c('black','grey'))
CHR <- rbPal1(2)[as.numeric(chr)]
chr1 <- cbind(CHR,CHR)
rbPal5 <- colorRampPalette(RColorBrewer::brewer.pal(n = 8, name = "Dark2")[2:1])
compreN_pred <- rbPal5(2)[as.numeric(factor(com.preN))]
cells <- rbind(compreN_pred,compreN_pred)
if (ncol(mat.adj)< 3000){
h <- 10
} else {
h <- 15
}
col_breaks = c(seq(-1,-0.4,length=50),seq(-0.4,-0.2,length=150),seq(-0.2,0.2,length=600),seq(0.2,0.4,length=150),seq(0.4, 1,length=50))
jpeg(paste(sample.name,"heatmap.jpeg",sep=""), height=h*250, width=4000, res=100)
#  heatmap.3(t(mat.adj),dendrogram="r", distfun = function(x) as.dist(1-cor(t(x), method = "spearman")), hclustfun = function(x) hclust(x, method="ward.D2"),
heatmap.3(t(mat.adj),dendrogram="r", distfun = function(x) parallelDist::parDist(x,threads =n.cores, method = "euclidean"), hclustfun = function(x) hclust(x, method="ward.D2"),
ColSideColors=chr1,RowSideColors=cells,Colv=NA, Rowv=TRUE,
notecol="black",col=my_palette,breaks=col_breaks, key=TRUE,
keysize=1, density.info="none", trace="none",
cexRow=0.1,cexCol=0.1,cex.main=1,cex.lab=0.1,
symm=F,symkey=F,symbreaks=T,cex=1, main=paste(WNS1,"; ",WNS, sep=""), cex.main=4, margins=c(10,10))
legend("topright", paste("pred.",names(table(com.preN)),sep=""), pch=15,col=RColorBrewer::brewer.pal(n = 8, name = "Dark2")[2:1], cex=1)
dev.off()
end_time<- Sys.time()
print(end_time -start_time)
reslts <- list(res, cbind(Aj$RNA.adj[, 1:3], mat.adj), hcc)
names(reslts) <- c("prediction", "CNAmat","hclustering")
return(reslts)
}
#' conver gene by cell matrix to genomic bins by cells matrix.
#'
#' @param DNA.mat input target bins, provided by copycat, with 220KB windows.
#' @param RNA.mat RNA data matrix with genes in rows.
#' @param full.anno annotation file for all known genes, automatically loaded in copycat.
#' @param n.cores number of cores for parallel computing.
#'
#' @return adjusted datamatrix with bins in rows, cells in columns.
#'
#' @examples
#' test.cab <- convert.all.bins(DNA.mat, RNA.mat, n.cores=10)
#'
#' test.cab.uber <- test.cab$RNAadj
#' @export
convert.all.bins.hg20 <- function(DNA.mat, RNA.mat, n.cores){
##make list obj for each window
DNA <- DNA.mat[-which(DNA.mat$chrom==24),]; dim(DNA)
end <- DNA$chrompos
start <- c(0, end[-length(end)])
ls.all <- list()
for(i in 1:nrow(DNA)){
sub.anno <- full.anno[which(full.anno$chromosome_name==DNA$chrom[i]),]
cent.gene <- 0.5*(sub.anno$start_position+sub.anno$end_position)
x <- sub.anno$hgnc_symbol[which(cent.gene<=end[i] & cent.gene>= start[i])]
if(length(x)==0){x <- "NA"}
ls.all[[i]] <- x
i<- i+1
}
##convert gene to bin
RNA <- RNA.mat[, 8:ncol(RNA.mat)]
###adj
R.ADJ <- function(i){
shr <- intersect(ls.all[[i]], RNA.mat$hgnc_symbol)
if(length(shr)>0){
Aj <- apply(RNA[which(RNA.mat$hgnc_symbol %in% shr), ], 2, median)
}
}
test.adj <- parallel::mclapply(1:nrow(DNA), R.ADJ, mc.cores = n.cores)
RNA.aj <- matrix(unlist(test.adj), ncol = ncol(RNA), byrow = TRUE)
colnames(RNA.aj) <- colnames(RNA.mat)[8:ncol(RNA.mat)]
mind <- which(test.adj=="NULL")
if(length(mind)>1){
ind <- 1:nrow(DNA)
Rw <- ind[-which(ind %in% mind)]
FK.again <- function(i){
fkI <- abs(Rw-mind[i])
fk <-  RNA.aj[which(fkI==min(fkI))[1], ]
}
tt.FK <-  parallel::mclapply(1:length(mind), FK.again, mc.cores = n.cores)
FK <- matrix(unlist(tt.FK), ncol = ncol(RNA), byrow = TRUE)
colnames(FK) <- colnames(RNA.mat)[8:ncol(RNA.mat)]
RNA.aj <- cbind(Rw, RNA.aj)
FK <- cbind(mind, FK)
RNA.co <- data.frame(rbind(RNA.aj, FK))
RNA.com <- RNA.co[order(RNA.co$Rw, decreasing = FALSE), ]
RNA.adj <- cbind(DNA[, 1:3], RNA.com[, 2:ncol(RNA.com)])
} else{
RNA.adj <- cbind(DNA[, 1:3], RNA.aj)
}
reslt <- list(DNA, RNA.adj)
names(reslt) <- c("DNA.adj", "RNA.adj")
return(reslt)
}
#' MCMC segmentation.
#'
#' @param fttmat transformed normalized data matrix; genes in rows; cell names in columns.
#' @param clu predefined clusters of cells.
#' @param sam.name given sample name.
#' @param bins minimal number of bins per segment.
#' @param cut.cor minimal KS difference to call breakpoints.
#' @param n.cores number of cores for parallel computing.
#'
#' @return 1) segmented CNA data matrix; 2) vector of breakpoints.
#'
#' @examples
#' test.mcmc <- CNA.MCMC(clu,fttmat, bins, cut.cor, n.cores=10)
#'
#' test.mcmc.seg.mat <- test.mamc$logCNA
#' @export
CNA.MCMC <- function(clu,fttmat, bins, cut.cor, n.cores){
CON<- NULL
for(i in min(clu):max(clu)){
data.c <- apply(fttmat[, which(clu==i)],1, median)
CON <- cbind(CON, data.c)
i <- i+1
}
norm.mat.sm <- exp(CON)
n <- nrow(norm.mat.sm)
BR <- NULL
for(c in 1:ncol(norm.mat.sm)){
breks <- c(seq(1, as.integer(n/bins-1)*bins, bins),n)
bre <- NULL
for (i in 1:(length(breks)-2)){
#i<-42
a1<-  max(mean(norm.mat.sm[breks[i]:breks[i+1],c]), 0.001)
posterior1 <-MCMCpack::MCpoissongamma(norm.mat.sm[breks[i]:breks[i+1],c], a1, 1, mc=1000)
a2 <- max(mean(norm.mat.sm[(breks[i+1]+1):breks[i+2],c]), 0.001)
posterior2 <-MCMCpack::MCpoissongamma(norm.mat.sm[(breks[i+1]+1):breks[i+2],c], a2, 1, mc=1000)
if (ks.test(posterior1,posterior2)$statistic[[1]] > cut.cor){
bre <- c(bre, breks[i+1])
}
i<- i+1
}
breks <- sort(unique(c(1, bre, n)))
BR <- sort(unique(c(BR, breks)))
c<-c+1
}
#print(paste(length(BR), " breakpoints", sep=""))
###CNA
norm.mat.sm <- exp(fttmat)
seg <- function(z){
x<-numeric(n)
for (i in 1:(length(BR)-1)){
a<- max(mean(norm.mat.sm[BR[i]:BR[i+1],z]), 0.001)
posterior1 <-MCMCpack::MCpoissongamma(norm.mat.sm[BR[i]:BR[i+1],z], a, 1, mc=1000)
x[BR[i]:BR[i+1]]<-mean(posterior1)
i<- i+1
}
x<-log(x)
}
seg.test <- parallel::mclapply(1:ncol(norm.mat.sm), seg, mc.cores = n.cores)
logCNA <- matrix(unlist(seg.test), ncol = ncol(norm.mat.sm), byrow = FALSE)
res <- list(logCNA, BR)
names(res) <- c("logCNA","breaks")
return(res)
}
#' find a cluster of diploid cells with integrative clustering method
#'
#' @param norm.mat.smooth smoothed data matrix; genes in rows; cell names in columns.
#' @param min.cells minimal number of cells per cluster.
#' @param n.cores number of cores for parallel computing.
#'
#' @return 1) predefined diploid cell names; 2) clustering results; 3) inferred baseline.
#'
#' @examples
#' test.bnc <- baseline.norm.cl(norm.mat.smooth=norm.mat.smooth, min.cells=5, n.cores=10)
#'
#' test.bnc.cells <- test.bnc$preN
#' @export
baseline.norm.cl <- function(norm.mat.smooth, min.cells=5, n.cores=n.cores){
d <- parallelDist::parDist(t(norm.mat.smooth), threads = n.cores) ##use smooth and segmented data to detect intra-normal cells
km <- 6
fit <- hclust(d, method="ward.D2")
ct <- cutree(fit, k=km)
while(!all(table(ct)>min.cells)){
km <- km -1
ct <- cutree(fit, k=km)
if(km==2){
break
}
}
SDM <-NULL
SSD <-NULL
for(i in min(ct):max(ct)){
data.c <- apply(norm.mat.smooth[, which(ct==i)],1, median)
sx <- max(c(0.05, 0.5*sd(data.c)))
GM3 <- mixtools::normalmixEM(data.c, lambda = rep(1,3)/3, mu = c(-0.2, 0, 0.2), sigma = sx,arbvar=FALSE,ECM=FALSE,maxit=5000)
SDM <- c(SDM, GM3$sigma[1])
SSD <- c(SSD, sd(data.c))
i <- i+1
}
wn <- mean(cluster::silhouette(cutree(fit, k=2), d)[, "sil_width"])
####
PDt <- pf(max(SDM)^2/min(SDM)^2, nrow(norm.mat.smooth), nrow(norm.mat.smooth), lower.tail = FALSE)
#PDt <- dt((min(SDM)-max(SDM))/mad(SDM),df=km-1)
# print(c("low sigma pvalue:", PDt))
#print(c("low sd pvalue:", dt((min(SSD)-max(SSD))/mad(SSD),df=km-1)))
if(wn <= 0.15|(!all(table(ct)>min.cells))| PDt > 0.05){
WNS <- "unclassified.prediction"
print("low confidence in classification")
}else {
WNS <- ""
}
basel <- apply(norm.mat.smooth[, which(ct %in% which(SDM==min(SDM)))], 1, median)
preN <- colnames(norm.mat.smooth)[which(ct %in% which(SDM==min(SDM)))]
### return both baseline and warning message
RE <- list(basel, WNS, preN, ct)
names(RE) <- c("basel", "WNS", "preN", "cl")
return(RE)
}
#' pre-define a group of normal cells with GMM.
#'
#' @param CNA.mat smoothed data matrix; genes in rows; cell names in columns.
#' @param max.normal find the first number diploid cells to save efforts.
#' @param mu.cut diploid baseline cutoff.
#' @param Nfraq.cut minimal fractoins of genomes with CNAs.
#'
#' @return 1) predefined diploid cell names; 2) clustering results; 3) inferred baseline.
#'
#' @examples
#' test.gmm <- baseline.GMM(CNA.mat=smooth.com, max.normal=30, mu.cut=0.05, Nfraq.cut=0.99)
#'
#' test.gmm.cells <- test.bnc$preN
#' @export
baseline.GMM <- function(CNA.mat, max.normal=15, mu.cut=0.05, Nfraq.cut=0.99, n.cores){
N.normal <-NULL
for(m in 1:ncol(CNA.mat)){
# print(paste("cell: ", m, sep=""))
sam <- CNA.mat[, m]
sg <- max(c(0.05, 0.5*sd(sam)));
GM3 <- mixtools::normalmixEM(sam, lambda = rep(1,3)/3, mu = c(-0.2, 0, 0.2),sigma = sg,arbvar=FALSE,ECM=FALSE,maxit=2000);#maxrestarts=10; arbmean=TRUE; arbvar=TRUE;epsilon=0.01
###decide normal or tumor
s <- sum(abs(GM3$mu)<=mu.cut)
if(s>=1){
frq <- sum(GM3$lambda[which(abs(GM3$mu)<=mu.cut)])
#   print(paste("N.fraq ", frq, sep=""))
#   print(paste("sigma: ", GM3$sigma[1], sep=""))
if(frq> Nfraq.cut){
pred <- "diploid"
}else{pred<-"aneuploid"}
}else {pred <- "aneuploid"}
#  print(paste("pred: ", pred, sep=""))
N.normal<- c(N.normal,pred)
if(sum(N.normal=="diploid")>=max.normal){break}
m<- m+1
}
names(N.normal) <- colnames(CNA.mat)[1:length(N.normal)]
preN <- names(N.normal)[which(N.normal=="diploid")]
d <- parallelDist::parDist(t(CNA.mat), threads = n.cores) ##use smooth and segmented data to detect intra-normal cells
km <- 6
fit <- hclust(d, method="ward.D2")
ct <- cutree(fit, k=km)
if(length(preN) == 15){
WNS <- ""
basel <- apply(CNA.mat[, which(colnames(CNA.mat) %in% preN)], 1, median)
RE <- list(basel, WNS, preN, ct)
names(RE) <- c("basel", "WNS", "preN", "cl")
return(RE)
}else {
WNS <- "unclassified.prediction"
RE <- list(WNS, preN)
names(RE) <- c("WNS", "preN")
return(RE)
}
RE <- list(basel, WNS, preN)
names(RE) <- c("basel", "WNS", "preN")
return(N.normal)
}
#' annotate genes with reference to hg38.
#'
#' @param mat data matrix; genes in rows; cell names in columns.
#' @param ID.type gene id type: Symbol or Ensemble.
#' @param full.anno annotation file for all known genes, automatically loaded in copycat.
#'
#' @return annotations of each genes in rows with chrom and positions.
#'
#' @examples
#' test.anno.mat <- annotateGenes.hg20(mat=matx, ID.type="ENSEMBLE_id", full.anno = full.anno)
#' @export
annotateGenes.hg20 <- function(mat, ID.type="S"){
print("start annotation ...")
if(substring(ID.type,1,1) %in% c("E", "e")){
shar <- intersect(rownames(mat), full.anno$ensembl_gene_id)
mat <- mat[which(rownames(mat) %in% shar),]
anno <- full.anno[which(as.vector(full.anno$ensembl_gene_id) %in% shar),]
anno <- anno[!duplicated(anno$hgnc_symbol),]
anno <- anno[order(match(anno$ensembl_gene_id, rownames(mat))),]
data <- cbind(anno, mat)
}else if(substring(ID.type,1,1) %in% c("S", "s")) {
shar <- intersect(rownames(mat), full.anno$hgnc_symbol)
mat <- mat[which(rownames(mat) %in% shar),]
anno <- full.anno[which(as.vector(full.anno$hgnc_symbol) %in% shar),]
anno <- anno[!duplicated(anno$hgnc_symbol),]
anno <- anno[order(match(anno$hgnc_symbol, rownames(mat))),]
data <- cbind(anno, mat)
}
}
